
Skip to content
This repository
Search
Pull requests
Issues
Marketplace
Explore
 @guoyapeng
Sign out
 Watch 0
 Star 4  Fork 6 13301338176/13301338176-ml
 Code  Issues 0  Pull requests 0  Projects 0  Wiki  Insights
13301338176-ml/mcts/mcts/n_in_row_uct_rave.py 
Newer           Older
RawNormal viewHistory
 100644  453 lines (378 sloc)  15.3 KB
@13301338176
AI
4 months ago
1
"""
2
author: arrti
3
github: https://github.com/arrti
4
blog:   http://www.cnblogs.com/xmwd
5
""" 
6

7
import copy
8
import time
9
from random import choice, shuffle
10
from math import log, sqrt
11

12

13
class Board(object):
14
    """
15
    board for game
16
    """
17

18
    def __init__(self, **kwargs):
19
        self.width = int(kwargs.get('width', 8))
20
        self.height = int(kwargs.get('height', 8))
21
        self.states = {} # board states, key:move, value: player as piece type
22
        self.n_in_row = int(kwargs.get('n_in_row', 5)) # need how many pieces in a row to win
23

24
    def init_board(self):
25
        if self.width < self.n_in_row or self.height < self.n_in_row:
26
            raise Exception('board width and height can not less than %d' % self.n_in_row)
27

28
        self.availables = list(range(self.width * self.height)) # available moves
29

30
        self.states = {} # key:move as location on the board, value:player as pieces type
31

32
    def move_to_location(self, move):
33
        """
34
        3*3 board's moves like:
35
        6 7 8
36
        3 4 5
37
        0 1 2
38
        and move 5's location is (1,2)
39
        """
40
        h = move  // self.width
41
        w = move  %  self.width
42
        return [h, w]
43

44
    def location_to_move(self, location):
45
        if(len(location) != 2):
46
            return -1
47
        h = location[0]
48
        w = location[1]
49
        move = h * self.width + w
50
        if(move not in range(self.width * self.height)):
51
            return -1
52
        return move
53

54
    def update(self, player, move):
55
        self.states[move] = player
56
        self.availables.remove(move)
57

58
    def current_state(self):
59
        return tuple((m, self.states[m]) for m in sorted(self.states)) # for hash
60

61

62
class MCTS(object):
63
    """
64
    AI player, UCT RAVE
65
    """
66

67
    def __init__(self, board, play_turn, n_in_row=5, time=5, max_actions=1000):
68
        self.board = board
69
        self.play_turn = play_turn
70
        self.calculation_time = float(time)
71
        self.max_actions = max_actions
72
        self.n_in_row = n_in_row
73

74
        self.player = play_turn[0] # AI is first at now
75
        self.confident = 1.96
76
        self.equivalence = 1000
77
        self.max_depth = 1
78

79
        self.plays = {}      # key:(action, state), value:visited times
80
        self.wins = {}       # key:(action, state), value:win times
81
        self.plays_rave = {} # key:(move, state), value:visited times
82
        self.wins_rave = {}  # key:(move, state), value:{player: win times}
83

84
    def get_action(self):
85
        if len(self.board.availables) == 1:
86
            return self.board.availables[0]
87

88
        simulations = 0
89
        begin = time.time()
90
        while time.time() - begin < self.calculation_time:
91
        # while simulations < 10000: # need many simulations for a better selection
92
            board_copy = copy.deepcopy(self.board)  # simulation will change board's states,
93
            play_turn_copy = copy.deepcopy(self.play_turn) # and play turn
94
            self.run_simulation(board_copy, play_turn_copy)
95
            simulations += 1
96

97
        print("total simulations=", simulations)
98

99
        move = self.select_one_move()
100
        location = self.board.move_to_location(move)
101
        print('Maximum depth searched:', self.max_depth)
102

103
        print("AI move: %d,%d\n" % (location[0], location[1]))
104

105
        self.prune()
106

107
        return move
108

109
    def run_simulation(self, board, play_turn):
110
        """
111
        UCT RAVE main process
112
        """
113

114
        plays = self.plays
115
        wins = self.wins
116
        plays_rave = self.plays_rave
117
        wins_rave = self.wins_rave
118
        availables = board.availables
119

120
        player = self.get_player(play_turn)
121
        visited_states = set()
122
        winner = -1
123
        expand = True
124
        states_list = []
125
        # Simulation
126
        for t in range(1, self.max_actions + 1):
127
            # Selection
128
            # if all moves have statistics info, choose one that have max UCB value
129
            state = board.current_state()
130
            actions = [(move, player) for move in availables]
131
            if all(plays.get((action, state)) for action in actions):
132
                total = 0
133
                for a, s in plays:
134
                    if s == state:
135
                        total += plays.get((a, s)) # N(s)
136
                beta = self.equivalence/(3 * total + self.equivalence)
137

138
                value, action = max(
139
                    ((1 - beta) * (wins[(action, state)] / plays[(action, state)]) +
140
                     beta * (wins_rave[(action[0], state)][player] / plays_rave[(action[0], state)]) + 
141
                     sqrt(self.confident * log(total) / plays[(action, state)]), action)
142
                    for action in actions)   # UCT RAVE
143

144
            else:
145
                # a simple strategy
146
                # prefer to choose the nearer moves without statistics,
147
                # and then the farthers.
148
                # try ro add statistics info to all moves quickly
149
                # adjacents = []
150
                # if len(availables) > self.n_in_row:
151
                #     adjacents = self.adjacent_moves(board, state, player, plays)
152

153
                # if len(adjacents):
154
                #     action = (choice(adjacents), player)
155
                # else:
156
                #     peripherals = []
157
                #     for action in actions:
158
                #         if not plays.get((action, state)):
159
                #             peripherals.append(action)
160
                #     action = choice(peripherals)
161
                action = choice(actions)           
162

163
            move, p = action
164
            board.update(player, move)
165

166
            # Expand
167
            # add only one new child node each time
168
            if expand and (action, state) not in plays:
169
                expand = False
170
                plays[(action, state)] = 0
171
                wins[(action, state)] = 0
172

173
                if t > self.max_depth:
174
                    self.max_depth = t
175

176
            states_list.append((action, state)) # states in one simulation by order of visited
177
            # for i, (m_root, s_root) in enumerate(states_list):
178
            #     for (m_sub, s_sub) in states_list[i:]:
179
            #         if (m_sub, s_root) not in plays_rave:
180
            #             plays_rave[(m_sub, s_root)] = 0 
181
            #             wins_rave[(m_sub, s_root)] = {}              
182
            #             for p in self.play_turn:
183
            #                 wins_rave[(m_sub, s_root)][p] = 0
184

185
            # AMAF value
186
            # next (action, state) is child node of all previous (action, state) nodes
187
            for (m, pp), s in states_list:
188
                if (move, s) not in plays_rave:
189
                    plays_rave[(move, s)] = 0 
190
                    wins_rave[(move, s)] = {}              
191
                    for p in self.play_turn:
192
                        wins_rave[(move, s)][p] = 0
193

194
            visited_states.add((action, state))
195

196
            is_full = not len(availables)
197
            win, winner = self.has_a_winner(board)
198
            if is_full or win:
199
                break
200

201
            player = self.get_player(play_turn)
202

203
        # Back-propagation
204
        for i, ((m_root, p), s_root) in enumerate(states_list):
205
            action = (m_root, p)
206
            if (action, s_root) in plays:
207
                plays[(action, s_root)] += 1 # all visited moves
208
                if player == winner and player in action:
209
                    wins[(action, s_root)] += 1 # only winner's moves
210

211
            for ((m_sub, p), s_sub) in states_list[i:]:
212
                plays_rave[(m_sub, s_root)] += 1 # all child nodes of s_root 
213
                if winner in wins_rave[(m_sub, s_root)]:                
214
                    wins_rave[(m_sub, s_root)][winner] += 1 # each node is divided by the player 
215

216
    def get_player(self, players):
217
        p = players.pop(0)
218
        players.append(p)
219
        return p
220

221
    def select_one_move(self):
222
        """
223
        select by win percentage 
224
        """
225
        percent_wins, move = max(
226
            (self.wins.get(((move, self.player), self.board.current_state()), 0) /
227
             self.plays.get(((move, self.player), self.board.current_state()), 1),
228
             move)
229
            for move in self.board.availables)
230

231
        # display the statistics for each possible play,
232
        # first is MC value, second is AMAF value
233
        for x in sorted(
234
                ((100 * self.wins.get(((move, self.player), self.board.current_state()), 0) /
235
                        self.plays.get(((move, self.player), self.board.current_state()), 1),
236
                  100 * self.wins_rave.get((move, self.board.current_state()), {}).get(self.player, 0) /
237
                        self.plays_rave.get((move, self.board.current_state()), 1),
238
                  self.wins.get(((move, self.player), self.board.current_state()), 0),
239
                  self.plays.get(((move, self.player), self.board.current_state()), 1),
240
                  self.wins_rave.get((move, self.board.current_state()), {}).get(self.player, 0),
241
                  self.plays_rave.get((move, self.board.current_state()), 1), 
242
                  self.board.move_to_location(move))
243
                 for move in self.board.availables),
244
                reverse=True):
245
            print('{6}: {0:.2f}%--{1:.2f}% ({2} / {3})--({4} / {5})'.format(*x))
246

247
        return move
248

249
    def adjacent_moves(self, board, state, player, plays):
250
        """
251
        adjacent moves without statistics info
252
        """
253
        moved = list(set(range(board.width * board.height)) - set(board.availables))
254
        adjacents = set()
255
        width = board.width
256
        height = board.height
257

258
        for m in moved:
259
            h = m // width
260
            w = m % width
261
            if w < width - 1:
262
                adjacents.add(m + 1) # right
263
            if w > 0:
264
                adjacents.add(m - 1) # left
265
            if h < height - 1:
266
                adjacents.add(m + width) # upper
267
            if h > 0:
268
                adjacents.add(m - width) # lower
269
            if w < width - 1 and h < height - 1:
270
                adjacents.add(m + width + 1) # upper right
271
            if w > 0 and h < height - 1:
272
                adjacents.add(m + width - 1) # upper left
273
            if w < width - 1 and h > 0:
274
                adjacents.add(m - width + 1) # lower right
275
            if w > 0 and h > 0:
276
                adjacents.add(m - width - 1) # lower left
277

278
        adjacents = list(set(adjacents) - set(moved))
279
        for move in adjacents:
280
            if plays.get(((move, player), state)):
281
                adjacents.remove(move)
282
        return adjacents
283

284
    def prune(self):
285
        """
286
        remove not selected path
287
        """
288
        length = len(self.board.states)
289
        keys = list(self.plays)
290
        for a, s in keys:
291
            if len(s) < length + 2:
292
                del self.plays[(a, s)]
293
                del self.wins[(a, s)]
294

295
        keys = list(self.plays_rave)
296
        for m, s in keys:
297
            if len(s) < length + 2:
298
                del self.plays_rave[(m, s)]
299
                del self.wins_rave[(m, s)]
300

301
    def has_a_winner(self, board):
302
        moved = list(set(range(board.width * board.height)) - set(board.availables))
303
        if(len(moved) < self.n_in_row + 2):
304
            return False, -1
305

306
        width = board.width
307
        height = board.height
308
        states = board.states
309
        n = self.n_in_row
310
        for m in moved:
311
            h = m // width
312
            w = m % width
313
            player = states[m]
314

315
            if (w in range(width - n + 1) and
316
                len(set(states.get(i, -1) for i in range(m, m + n))) == 1):
317
                return True, player
318

319
            if (h in range(height - n + 1) and
320
                len(set(states.get(i, -1) for i in range(m, m + n * width, width))) == 1):
321
                return True, player
322

323
            if (w in range(width - n + 1) and h in range(height - n + 1) and
324
                len(set(states.get(i, -1) for i in range(m, m + n * (width + 1), width + 1))) == 1):
325
                return True, player
326

327
            if (w in range(n - 1, width) and h in range(height - n + 1) and
328
                len(set(states.get(i, -1) for i in range(m, m + n * (width - 1), width - 1))) == 1):
329
                return True, player
330

331
        return False, -1
332

333
    def __str__(self):
334
        return "AI"
335

336

337
class Human(object):
338
    """
339
    human player
340
    """
341

342
    def __init__(self, board, player):
343
        self.board = board
344
        self.player = player
345

346
    def get_action(self):
347
        try:
348
            location = [int(n, 10) for n in input("Your move: ").split(",")]
349
            move = self.board.location_to_move(location)
350
        except Exception as e:
351
            move = -1
352
        if move == -1 or move not in self.board.availables:
353
            print("invalid move")
354
            move = self.get_action()
355
        return move
356

357
    def __str__(self):
358
        return "Human"
359

360

361
class Game(object):
362
    """
363
    game server
364
    """
365

366
    def __init__(self, board, **kwargs):
367
        self.board = board
368
        self.player = [1, 2] # player1 and player2
369
        self.n_in_row = int(kwargs.get('n_in_row', 5))
370
        self.time = float(kwargs.get('time', 5))
371
        self.max_actions = int(kwargs.get('max_actions', 1000))
372

373
    def start(self):
374
        p1, p2 = self.init_player()
375
        self.board.init_board()
376

377
        ai = MCTS(self.board, [p1, p2], self.n_in_row, self.time, self.max_actions)
378
        human = Human(self.board, p2)
379
        players = {}
380
        players[p1] = ai
381
        players[p2] = human
382
        turn = [p1, p2]
383
        shuffle(turn)
384
        self.graphic(self.board, human, ai)
385
        while(1):
386
            p = turn.pop(0)
387
            turn.append(p)
388
            player_in_turn = players[p]
389
            move = player_in_turn.get_action()
390
            self.board.update(p, move)
391
            self.graphic(self.board, human, ai)
392
            end, winner = self.game_end(ai)
393
            if end:
394
                if winner != -1:
395
                    print("Game end. Winner is", players[winner])
396
                break
397

398
    def init_player(self):
399
        plist = list(range(len(self.player)))
400
        index1 = choice(plist)
401
        plist.remove(index1)
402
        index2 = choice(plist)
403

404
        return self.player[index1], self.player[index2]
405

406
    def game_end(self, ai):
407
        win, winner = ai.has_a_winner(self.board)
408
        if win:
409
            return True, winner
410
        elif not len(self.board.availables):
411
            print("Game end. Tie")
412
            return True, -1
413
        return False, -1
414

415
    def graphic(self, board, human, ai):
416
        """
417
        Draw the board and show game info
418
        """
419
        width = board.width
420
        height = board.height
421

422
        print("Human Player", human.player, "with X".rjust(3))
423
        print("AI    Player", ai.player, "with O".rjust(3))
424
        print()
425
        for x in range(width):
426
            print("{0:8}".format(x), end='')
427
        print('\r\n')
428
        for i in range(height - 1, -1, -1):
429
            print("{0:4d}".format(i), end='')
430
            for j in range(width):
431
                loc = i * width + j
432
                p = board.states.get(loc, -1)
433
                if p == human.player:
434
                    print('X'.center(8), end='')
435
                elif p == ai.player:
436
                    print('O'.center(8), end='')
437
                else:
438
                    print('_'.center(8), end='')
439
            print('\r\n\r\n')
440

441

442
def run():
443
    n = 4
444
    try:
445
        board = Board(width=5, height=5, n_in_row=n)
446
        game = Game(board, n_in_row=n, time=15) # more time better
447
        game.start()
448
    except KeyboardInterrupt:
449
        print('\n\rquit')
450

451
if __name__ == '__main__':
452
    run()
© 2018 GitHub, Inc.
Terms
Privacy
Security
Status
Help
Contact GitHub
API
Training
Shop
Blog
About
Press h to open a hovercard with more details.
